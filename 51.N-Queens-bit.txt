/*
1.~ : 按位取反,二进制表示中的1变为0，0变为1。比如32位系统下，0x0F取反就是0xFFFFFFF0。
~0x0F; // => 0xFFFFFFF0 (bitwise negation)

2.&:按位与时，两个1相与得1，其他情况均得0。（有0则0）0x0F & 0xF0; // => 0x00 (bitwise AND)

3.|:按位或时，两个0相或得0，其他情况均得1。（有1则1）0x0F & 0xF0; // => 0xFF (bitwise OR)

4.^ :  x和y异或时，若x，y不同（一个是0一个是1）则结果为1，若x，y相同（都是0或者都是1）则结果为0。
0x04 ^ 0x0F; // => 0x0B (bitwise XOR)


5.移位:将数字左移或右移，比如0000 1011左移一位就会变成0001 0110，右移一位就变成了0000 0101。
要注意的有两点，第一是，左移一位相当于乘以2，右移一位相当于除以2。
第二是移位时空出来的位是用0补充的，因此对于有符号数的移位需要特别小心。
0x01 << 1; // => 0x02 (bitwise left shift (by 1))
0x02 >> 1; // => 0x01 (bitwise right shift (by 1))


八皇后问题与位运算
每一行只能放并且必须放一个皇后。每次放置一个皇后之后，它就会对后面所有行中，可能放置皇后的位置产生影响。
如下图所示，我们已经放置了三个皇后1，2，3。 接着在下面一行放置4时，用字母标识的区域都是不可行的方案，
会与已经放置的三个皇后产生冲突。 这个冲突其实有三种不同的情况，我们用三个变量A，B，C分别来表示这三种不同的冲突。
这三个变量都是8位的二进制数，这8位中，为1的表示有冲突，为0表示没有冲突。

1. 与已放置的皇后处于同一列中；
我们用B表示这种冲突。例如在图中，第四行会有三个位置因为列攻击而不能再放置皇后（图中r），因此B = 1000 1001。

2. 与已放置的皇后处于同一主对角线中(指向右下方),我们用A表示这种冲突。
在图中，b表示的位置，分别是由于1和2的斜对角线上的攻击而不能够放置新的皇后， 因此A = 0001 0010。

3. 与已放置的皇后处于同一次对角线中(指向右上方) 我们用C表示这种冲突。
例如图中粉色方块， 是由2的斜对角线的攻击造成的。因此C = 0010 0000。

r- Red  b-Blue  p-Pink

1 - - - - - - -  one
- - - - 2 - - -  two
- - - - - - - 3  three     B(r) = 1000 1001
r - p b r - b r  four      A(b) = 0001 0010
- - - - - - - -  five      C(p) = 0010 0000
- - - - - - - -  six
- - - - - - - -  seven
- - - - - - - -  eight

有了A，B，C，三个变量，我们很容易求出当前这一行中，有哪些位置是可以放置皇后的。
这个变量我们用D来表示，我们可以写出D = ~(A|B|C)。D中为1的那些位置则是我们可以放置皇后的位置。

在上图的情况下，D = 0100 0100。此时，我们有两个可能的放置皇后的位置，那么要如何取出第一个位置呢？
这里有一个技巧。我们用bit表示可能的一个位置，使用bit = D & (-D)即可取出D中最右边的一个1。
例如D = 0100 0100，则-D = 10111100（注意计算机中的数都是补码）。而bit = D & (-D) = 0000 0100 取出了最右边的那个1。

D -= bit; // 将D最右边为1的bit清零 也就是为获取下一次的最右可用列使用做准备 程序将来会回溯到这个位置继续试探

最后还有一点，如何递归？递归中传入的参数（也即A，B，C）该如何设定？其实也很简单，特别是对于列冲突变量B来说，只要使用B|bit即可表示下一行列冲突的情况，
对于A，采用(A|bit)<<1，
对于C，采用(C|bit>>1)
即可表示下一行中，对角线冲突的情况。
#include <stdio.h>

int count = 0;

void try(unsigned char A, unsigned char B, unsigned char C){
if(B==255){
count ++;
return;
}
unsigned char D = ~(A|B|C);
while(D){
unsigned char bit = D & (-D);
D -= bit;       // 将D最右边为1的bit清零 也就是为获取下一次的最右可用列使用做准备 程序将来会回溯到这个位置继续试探
try((A|bit)>>1, B|bit, (C|bit)<<1);
}
}
int main(){
try(0, 0, 0);
printf("%d\n", count);
}
*/


#include<iostream>
#include <vector>
#include <time.h>
using namespace std;

/*
* *   N皇后回溯算法* N Queens Problem* 试探-回溯算法  15皇后6s
* *   此算法总是将 第一个皇后放到第一行的最后列开始
*/

// sum用来记录皇后放置成功的不同布局数；upperlim用来标记所有列初始化数字1,左移N位就是N个1
long sum = 0, upperlim = (1 << 15) - 1;//左移15表示15方格

// 试探算法从最右边的列开始,    第一个皇后放到第一行的最后列
void queen(long row, long ld, long rd)   
{
	if (row != upperlim)
	{
		// row，ld，rd进行“或”运算，求得所有可以放置皇后的列, 
		// 然后再取反后“与”上全1的数，来求得当前所有可以放置皇后的位置，对应列改为1
		// 也就是求取当前哪些列可以放置皇后
		long pos = upperlim & ~(row | ld | rd);//所有可以放的位置
		 
		while (pos != 0) // 0 -- 皇后没有地方可放，回溯
		{
			// 拷贝pos最右边为1的bit，其余bit置0
			// 也就是取得可以放皇后的最右边的列
			long p = pos & -pos;//最右边的位置

			// row + p，将当前列置1，表示记录这次皇后放置的列。
			// (ld + p) << 1，标记当前皇后左边相邻的列不允许下一个皇后放置。
			// (ld + p) >> 1，标记当前皇后右边相邻的列不允许下一个皇后放置。
			// 此处的移位操作实际上是记录对角线上的限制，只是因为问题都化归
			// 到一行网格上来解决，所以表示为列的限制就可以了。显然，随着移位
			// 在每次选择列之前进行，原来N×N网格中某个已放置的皇后针对其对角线
			// 上产生的限制都被记录下来了
			queen(row + p, (ld + p) << 1, (rd + p) >> 1);
			// 将pos最右边为1的bit清零
			// 也就是为获取下一次的最右可用列使用做准备，
			// 程序将来会回溯到这个位置继续试探
			pos -= p;
		}
	}
	else
	{
		// row的所有位都为1，即找到了一个成功的布局，回溯
		sum++;
	}
}

int q(int l, int r, int m, int n, int i, int j)
{
	return j ? i ? q(l, r, m, n, i&i - 1, 1) +
		q((l | i& -i) * 2, (r | i& -i) / 2, m | i&-i, n, 0, 0) : 0 : m == n ? 1 : q(l, r, m, n, ~(l | r | m)& n, 1);//除2用>>1代替,*2用<<1,速度会更快
}


int main(int argc, char* argv[])
{
	time_t start, end;//计算开始时间
	double cost;
	time(&start);

	//目前最快,八皇后位操作方法1:  15皇后6s
	queen(0, 0, 0);

	time(&end);
	cost = difftime(end, start);

	cout << "方法1: x皇后问题总可行摆放总数为: " << sum << " 计算时间为: " << cost << "s" << endl;



	/*
	//八皇后位操作方法2
	for (int n = 0; n++<15;)
	{
		time(&start);

		long sum = q(0, 0, 0, (1 << n) - 1, 0, 0);

		time(&end);
		cost = difftime(end, start);

		cout << "方法2: " << n << "皇后问题总可行摆放总数为: " << sum << " 计算时间为: " << cost << "s" << endl;

	}*/
	return 0;
}