/*96.Unique Binary Search Trees
Given n, how many structurally unique BST's (binary search trees) that store values 1...n?
For example,
Given n = 3, there are a total of 5 unique BST's.

1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3

该问题可以用动态编程方式解决。我将在下面解释直觉和公式。
给定序列1 ... n，从序列中构建二进制搜索树（BST），我们可以枚举序列中的每个数字i，并且使用数字作为根，当然，子序列1 ...（i-1）在左侧将位于根的左侧分支，
类似地，正确的子序列（i + 1）... n位于根的右侧分支。然后我们可以从子序列递归地构造子树。通过上述方法，我们可以确保我们构建的BST是独一无二的，因为它们
具有独特的根源。
问题是计算唯一BST的数量。为此，我们需要定义两个功能：
G(n)：长度为n的序列的唯一BST的数量。
F(i, n), 1 <= i <= n：唯一BST的数量，其中数字i是BST的根，序列的范围从1到n。
可以看出，G(n)为了解决问题，我们需要计算的实际功能。并且G(n)可以从中推导出来F(i, n)，最终将递归地引用G(n)。
首先，考虑到上述定义，我们可以看到唯一BST G(n)的总数是F(i)使用每个数字i作为根的BST的总和。
即G(n) = F(1, n) + F(2, n) + ... + F(n, n).
特别地，底部的情况下，只有一个组合来构造长度为1（只有根）或0（空树）的序列中的BST。
即G(0)=1, G(1)=1.
给定一个序列1 ... n，我们选择序列中的数字i作为根，然后具有指定根的唯一BST F(i)的数量是其左和右子树的BST数的笛卡尔乘积。例如F(3, 7)：以3为根的唯一BST树的数量。
以3为根，从整个序列[1,2,3,4,5,6,7]中构建一个唯一的BST，也就是说，我们需要从其左子序列[1]中构建一个唯一的BST ，2]和另一个BST在正确的子序列[ 4,5,6,7 ]中，
然后将它们组合在一起（即笛卡尔乘积）。棘手的部分是我们可以考虑序列[1,2] G(2)中唯一的BST的数目，以及序列中唯一的BST的数目[4,5,6,7] G(4)。因此，
F(3,7) = G(2) * G(4)。
即F(i, n) = G(i-1) * G(n-i)	1 <= i <= n
结合上述两个公式，我们得到了递归公式G(n)。即
G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)
在计算方面，我们需要从较低的数字开始，因为G(n)取决于值的值G(0) … G(n-1)。
*/

//96.Unique Binary Search Trees
/*Given n, how many structurally unique BST's (binary search trees) that store values 1...n?
For example,
Given n = 3, there are a total of 5 unique BST's.

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
这道题实际上是 Catalan Number卡塔兰数的一个例子，如果对卡塔兰数不熟悉的童鞋可能真不太好做。话说其实我也是今天才知道的好嘛-.-|||，为啥我以前都不知道捏？！
为啥卡塔兰数不像斐波那契数那样人尽皆知呢，是我太孤陋寡闻么？！不过今天知道也不晚，不断的学习新的东西，这才是意义所在嘛! 好了
赶紧回到题目上来吧。我们先来看当 n = 1的情况，只能形成唯一的一棵二叉搜索树，n分别为1,2,3的情况如下所示：

1                        n = 1

2        1                   n = 2
/          \
1            2

1         3     3      2      1           n = 3
\       /     /      / \      \
3     2     1      1   3      2
/     /       \                 \
2     1         2                 3
就跟斐波那契数列一样，我们把n = 0 时赋为1，因为空树也算一种二叉搜索树，那么n = 1时的情况可以看做是其左子树个数乘以右子树的个数，左右字数都是空树，
所以1乘1还是1。那么n = 2时，由于1和2都可以为跟，分别算出来，再把它们加起来即可。n = 2的情况可由下面式子算出：

dp[2] =  dp[0] * dp[1]　　　(1为根的情况)

　　　　+ dp[1] * dp[0]　　  (2为根的情况)

	同理可写出 n = 3 的计算方法：

	dp[3] =  dp[0] * dp[2]　　　(1为根的情况)

	　　　　+ dp[1] * dp[1]　　  (2为根的情况)

		　　　  + dp[2] * dp[0]　　  (3为根的情况)

			 由此可以得出卡塔兰数列的递推式为：*/
class S96 {
public:
	int numTrees(int n) {
		vector<int> dp(n + 1, 0);
		dp[0] = 1;
		dp[1] = 1;
		for (int i = 2; i <= n; ++i) {
			for (int j = 0; j < i; ++j) {
				dp[i] += dp[j] * dp[i - j - 1];
			}
		}
		return dp[n];
	}
};